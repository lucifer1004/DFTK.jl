<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · DFTK.jl</title><meta name="title" content="API reference · DFTK.jl"/><meta property="og:title" content="API reference · DFTK.jl"/><meta property="twitter:title" content="API reference · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/api/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/api/"/><link rel="canonical" href="https://docs.dftk.org/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../guide/installation/">Installation</a></li><li><a class="tocitem" href="../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../guide/periodic_problems/">Problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../guide/introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../examples/dielectric/">Eigenvalues of the dielectric matrix</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../examples/wannier90/">Wannierization using Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../examples/compare_solvers/">Comparison of DFT solvers</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../developer/setup/">Developer setup</a></li><li><a class="tocitem" href="../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../developer/gpu_computations/">GPU computations</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This page provides a plain list of all documented functions, structs, modules and macros in DFTK. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DFTK" href="#DFTK.DFTK"><code>DFTK.DFTK</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DFTK –- The density-functional toolkit. Provides functionality for experimenting with plane-wave density-functional theory algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/DFTK.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.timer" href="#DFTK.timer"><code>DFTK.timer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>TimerOutput object used to store DFTK timings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/timer.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AbstractArchitecture" href="#DFTK.AbstractArchitecture"><code>DFTK.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for architectures supported by DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/architecture.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AdaptiveBands" href="#DFTK.AdaptiveBands"><code>DFTK.AdaptiveBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dynamically adapt number of bands to be converged to ensure that the orbitals of lowest occupation are occupied to at most <code>occupation_threshold</code>. To obtain rapid convergence of the eigensolver a gap between the eigenvalues of the last occupied orbital and the last computed (but not converged) orbital of <code>gap_min</code> is ensured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/nbands_algorithm.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Applyχ0Model" href="#DFTK.Applyχ0Model"><code>DFTK.Applyχ0Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Full χ0 application, optionally dropping terms or disabling Sternheimer. All keyword arguments passed to <a href="#DFTK.apply_χ0-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, AbstractArray{T}}} where T"><code>apply_χ0</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/chi0models.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AtomicLocal" href="#DFTK.AtomicLocal"><code>DFTK.AtomicLocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Atomic local potential defined by <code>model.atoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/local.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AtomicNonlocal" href="#DFTK.AtomicNonlocal"><code>DFTK.AtomicNonlocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal term coming from norm-conserving pseudopotentials in Kleinmann-Bylander form. <span>$\text{Energy} = \sum_a \sum_{ij} \sum_{n} f_n &lt;ψ_n|p_{ai}&gt; D_{ij} &lt;p_{aj}|ψ_n&gt;.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/nonlocal.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupAbinit" href="#DFTK.BlowupAbinit"><code>DFTK.BlowupAbinit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as used in Abinit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/kinetic.jl#L94-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupCHV" href="#DFTK.BlowupCHV"><code>DFTK.BlowupCHV</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as proposed in https://arxiv.org/abs/2210.00442 The blow-up order of the function is fixed to ensure C^2 regularity of the energies bands away from crossings and Lipschitz continuity at crossings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/kinetic.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupIdentity" href="#DFTK.BlowupIdentity"><code>DFTK.BlowupIdentity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default blow-up corresponding to the standard kinetic energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/kinetic.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DielectricMixing" href="#DFTK.DielectricMixing"><code>DFTK.DielectricMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We use a simplification of the Resta model DOI 10.1103/physrevb.16.2717 and set <span>$χ_0(q) = \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)}$</span> where <span>$C_0 = 1 - ε_r$</span> with <span>$ε_r$</span> being the macroscopic relative permittivity. We neglect <span>$K_\text{xc}$</span>, such that <span>$J^{-1} ≈ \frac{k_{TF}^2 - C_0 G^2}{ε_r k_{TF}^2 - C_0 G^2}$</span></p><p>By default it assumes a relative permittivity of 10 (similar to Silicon). <code>εr == 1</code> is equal to <code>SimpleMixing</code> and <code>εr == Inf</code> to <code>KerkerMixing</code>. The mixing is applied to <span>$ρ$</span> and <span>$ρ_\text{spin}$</span> in the same way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DielectricModel" href="#DFTK.DielectricModel"><code>DFTK.DielectricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A localised dielectric model for <span>$χ_0$</span>:</p><p class="math-container">\[\sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <code>L(r)</code> is a real-space localization function and otherwise the same conventions are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/chi0models.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DivAgradOperator" href="#DFTK.DivAgradOperator"><code>DFTK.DivAgradOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal &quot;divAgrad&quot; operator <span>$-½ ∇ ⋅ (A ∇)$</span> where <span>$A$</span> is a scalar field on the real-space grid. The <span>$-½$</span> is included, such that this operator is a generalisation of the kinetic energy operator (which is obtained for <span>$A=1$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementCohenBergstresser-Tuple{Any}" href="#DFTK.ElementCohenBergstresser-Tuple{Any}"><code>DFTK.ElementCohenBergstresser</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element where the interaction with electrons is modelled as in <a href="https://doi.org/10.1103/PhysRev.141.789">CohenBergstresser1966</a>. Only the homonuclear lattices of the diamond structure are implemented (i.e. Si, Ge, Sn).</p><p><code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementCoulomb-Tuple{Any}" href="#DFTK.ElementCoulomb-Tuple{Any}"><code>DFTK.ElementCoulomb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a bare Coulomb potential (for all-electron calculations) <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementGaussian-Tuple{Any, Any}" href="#DFTK.ElementGaussian-Tuple{Any, Any}"><code>DFTK.ElementGaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a Gaussian potential. Symbol is non-mandatory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L195-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementPsp-Tuple{Any}" href="#DFTK.ElementPsp-Tuple{Any}"><code>DFTK.ElementPsp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a pseudopotential model. <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Energies" href="#DFTK.Energies"><code>DFTK.Energies</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple struct to contain a vector of energies, and utilities to print them in a nice format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Energies.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Entropy" href="#DFTK.Entropy"><code>DFTK.Entropy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Entropy term -TS, where S is the electronic entropy. Turns the energy E into the free energy F=E-TS. This is in particular useful because the free energy, not the energy, is minimized at self-consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/entropy.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Ewald" href="#DFTK.Ewald"><code>DFTK.Ewald</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Ewald term: electrostatic energy per unit cell of the array of point charges defined by <code>model.atoms</code> in a uniform background of compensating charge yielding net neutrality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/ewald.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromFourier" href="#DFTK.ExternalFromFourier"><code>DFTK.ExternalFromFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from the (unnormalized) Fourier coefficients <code>V(G)</code> G is passed in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/local.jl#L57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromReal" href="#DFTK.ExternalFromReal"><code>DFTK.ExternalFromReal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from an analytic function <code>V</code> (in cartesian coordinates). No low-pass filtering is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/local.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromValues" href="#DFTK.ExternalFromValues"><code>DFTK.ExternalFromValues</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential given as values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/local.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FermiTwoStage" href="#DFTK.FermiTwoStage"><code>DFTK.FermiTwoStage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Two-stage Fermi level finding algorithm starting from a Gaussian-smearing guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/occupation.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FixedBands" href="#DFTK.FixedBands"><code>DFTK.FixedBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>In each SCF step converge exactly <code>n_bands_converge</code>, computing along the way exactly <code>n_bands_compute</code> (usually a few more to ease convergence in systems with small gaps).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/nbands_algorithm.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FourierMultiplication" href="#DFTK.FourierMultiplication"><code>DFTK.FourierMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Fourier space multiplication, like a kinetic energy term: (Hψ)(G) = multiplier(G) ψ(G).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray" href="#DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray"><code>DFTK.GPU</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a particular GPU architecture by passing the ArrayType</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/architecture.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Hartree" href="#DFTK.Hartree"><code>DFTK.Hartree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Hartree term: for a decaying potential V the energy would be</p><p>1/2 ∫ρ(x)ρ(y)V(x-y) dxdy</p><p>with the integral on x in the unit cell and of y in the whole space. For the Coulomb potential with periodic boundary conditions, this is rather</p><p>1/2 ∫ρ(x)ρ(y) G(x-y) dx dy</p><p>where G is the Green&#39;s function of the periodic Laplacian with zero mean (-Δ G = sum<em>{R} 4π δ</em>R, integral of G zero on a unit cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/hartree.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.KerkerDosMixing" href="#DFTK.KerkerDosMixing"><code>DFTK.KerkerDosMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The same as <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, but the Thomas-Fermi wavevector is computed from the current density of states at the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.KerkerMixing" href="#DFTK.KerkerMixing"><code>DFTK.KerkerMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kerker mixing: <span>$J^{-1} ≈ \frac{|G|^2}{k_{TF}^2 + |G|^2}$</span> where <span>$k_{TF}$</span> is the Thomas-Fermi wave vector. For spin-polarized calculations by default the spin density is not preconditioned. Unless a non-default value for <span>$ΔDOS_Ω$</span> is specified. This value should roughly be the expected difference in density of states (per unit volume) between spin-up and spin-down.</p><p>Notes:</p><ul><li>Abinit calls <span>$1/k_{TF}$</span> the dielectric screening length (parameter <em>dielng</em>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Kinetic" href="#DFTK.Kinetic"><code>DFTK.Kinetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kinetic energy: 1/2 sum<em>n f</em>n ∫ |∇ψn|^2 * blowup(-i∇Ψ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/kinetic.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Kpoint" href="#DFTK.Kpoint"><code>DFTK.Kpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discretization information for <span>$k$</span>-point-dependent quantities such as orbitals. More generally, a <span>$k$</span>-point is a block of the Hamiltonian; eg collinear spin is treated by doubling the number of kpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LazyHcat" href="#DFTK.LazyHcat"><code>DFTK.LazyHcat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple wrapper to represent a matrix formed by the concatenation of column blocks: it is mostly equivalent to hcat, but doesn&#39;t allocate the full matrix. LazyHcat only supports a few multiplication routines: furthermore, a multiplication involving this structure will always yield a plain array (and not a LazyHcat structure). LazyHcat is a lightweight subset of BlockArrays.jl&#39;s functionalities, but has the advantage to be able to store GPU Arrays (BlockArrays is heavily built on Julia&#39;s CPU Array).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/eigen/lobpcg_hyper_impl.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LdosModel" href="#DFTK.LdosModel"><code>DFTK.LdosModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the LDOS-based <span>$χ_0$</span> model</p><p class="math-container">\[χ_0(r, r&#39;) = (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states and <span>$D$</span> the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/chi0models.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}" href="#DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}"><code>DFTK.LibxcDensities</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute density in real space and its derivatives starting from ρ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/xc.jl#L278-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LocalNonlinearity" href="#DFTK.LocalNonlinearity"><code>DFTK.LocalNonlinearity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Local nonlinearity, with energy ∫f(ρ) where ρ is the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/local_nonlinearity.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Magnetic" href="#DFTK.Magnetic"><code>DFTK.Magnetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic term <span>$A⋅(-i∇)$</span>. It is assumed (but not checked) that <span>$∇⋅A = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/magnetic.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.MagneticFieldOperator" href="#DFTK.MagneticFieldOperator"><code>DFTK.MagneticFieldOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic field operator A⋅(-i∇).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Tuple{AtomsBase.AbstractSystem}" href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(system::AbstractSystem; kwargs...)</code></pre><p>AtomsBase-compatible Model constructor. Sets structural information (<code>atoms</code>, <code>positions</code>, <code>lattice</code>, <code>n_electrons</code> etc.) from the passed <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(lattice, atoms, positions; n_electrons, magnetic_moments, terms, temperature,
      smearing, spin_polarization, symmetries)</code></pre><p>Creates the physical specification of a model (without any discretization information).</p><p><code>n_electrons</code> is taken from <code>atoms</code> if not specified.</p><p><code>spin_polarization</code> is :none by default (paired electrons) unless any of the elements has a non-zero initial magnetic moment. In this case the spin_polarization will be :collinear.</p><p><code>magnetic_moments</code> is only used to determine the symmetry and the <code>spin_polarization</code>; it is not stored inside the datastructure.</p><p><code>smearing</code> is Fermi-Dirac if <code>temperature</code> is non-zero, none otherwise</p><p>The <code>symmetries</code> kwarg allows (a) to pass <code>true</code> / <code>false</code> to enable / disable the automatic determination of lattice symmetries or (b) to pass an explicit list of symmetry operations to use for lowering the computational effort. The default behaviour is equal to <code>true</code>, namely that the code checks the specified model in form of the Hamiltonian <code>terms</code>, <code>lattice</code>, <code>atoms</code> and <code>magnetic_moments</code> parameters and from these automatically determines a set of symmetries it can safely use. If you want to pass custom symmetry operations (e.g. a reduced or extended set) use the <code>symmetry_operations</code> function. Notice that this may lead to wrong results if e.g. the external potential breaks some of the passed symmetries. Use <code>false</code> to turn off symmetries completely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L67-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Union{Tuple{Model}, Tuple{T}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{Model}, Tuple{T}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(model; [lattice, positions, atoms, kwargs...])
Model{T}(model; [lattice, positions, atoms, kwargs...])</code></pre><p>Construct an identical model to <code>model</code> with the option to change some of the contained parameters. This constructor is useful for changing the data type in the model or for changing <code>lattice</code> or <code>positions</code> in geometry/lattice optimisations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L206-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NbandsAlgorithm" href="#DFTK.NbandsAlgorithm"><code>DFTK.NbandsAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NbandsAlgorithm subtypes determine how many bands to compute and converge in each SCF step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/nbands_algorithm.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NonlocalOperator" href="#DFTK.NonlocalOperator"><code>DFTK.NonlocalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal operator in Fourier space in Kleinman-Bylander format, defined by its projectors P matrix and coupling terms D: Hψ = PDP&#39; ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NoopOperator" href="#DFTK.NoopOperator"><code>DFTK.NoopOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Noop operation: don&#39;t do anything. Useful for energy terms that don&#39;t depend on the orbitals at all (eg nuclei-nuclei interaction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PairwisePotential-Tuple{Any, Any}" href="#DFTK.PairwisePotential-Tuple{Any, Any}"><code>DFTK.PairwisePotential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairwise terms: Pairwise potential between nuclei, e.g., Van der Waals potentials, such as Lennard—Jones terms. The potential is dependent on the distance between to atomic positions and the pairwise atomic types: For a distance <code>d</code> between to atoms <code>A</code> and <code>B</code>, the potential is <code>V(d, params[(A, B)])</code>. The parameters <code>max_radius</code> is of <code>100</code> by default, and gives the maximum distance (in Cartesian coordinates) between nuclei for which we consider interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/pairwise.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A plane-wave discretized <code>Model</code>. Normalization conventions:</p><ul><li>Things that are expressed in the G basis are normalized so that if <span>$x$</span> is the vector, then the actual function is <span>$\sum_G x_G e_G$</span> with <span>$e_G(x) = e^{iG x} / \sqrt(\Omega)$</span>, where <span>$\Omega$</span> is the unit cell volume. This is so that, eg <span>$norm(ψ) = 1$</span> gives the correct normalization. This also holds for the density and the potentials.</li><li>Quantities expressed on the real-space grid are in actual values.</li></ul><p><code>ifft</code> and <code>fft</code> convert between these representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L30-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{Model}" href="#DFTK.PlaneWaveBasis-Tuple{Model}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a <code>PlaneWaveBasis</code> using the kinetic energy cutoff <code>Ecut</code> and a Monkhorst-Pack <span>$k$</span>-point grid. The MP grid can either be specified directly with <code>kgrid</code> providing the number of points in each dimension and <code>kshift</code> the shift (0 or 1/2 in each direction). If not specified a grid is generated using <code>kgrid_from_minimal_spacing</code> with a minimal spacing of <code>2π * 0.022</code> per Bohr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L331-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, AbstractVector, AbstractVector}" href="#DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, AbstractVector, AbstractVector}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a new basis identical to <code>basis</code>, but with a custom set of kpoints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L347-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PreconditionerNone" href="#DFTK.PreconditionerNone"><code>DFTK.PreconditionerNone</code></a> — <span class="docstring-category">Type</span></header><section><div><p>No preconditioning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/eigen/preconditioners.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PreconditionerTPA" href="#DFTK.PreconditionerTPA"><code>DFTK.PreconditionerTPA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(simplified version of) Tetter-Payne-Allan preconditioning ↑ M.P. Teter, M.C. Payne and D.C. Allan, Phys. Rev. B 40, 12255 (1989).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/eigen/preconditioners.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspCorrection" href="#DFTK.PspCorrection"><code>DFTK.PspCorrection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pseudopotential correction energy. TODO discuss the need for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/psp_correction.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspHgh-Tuple{Any}" href="#DFTK.PspHgh-Tuple{Any}"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspHgh(path[, identifier, description])</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998) from file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspHgh.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspUpf-Tuple{Any}" href="#DFTK.PspUpf-Tuple{Any}"><code>DFTK.PspUpf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspUpf(path[, identifier])</code></pre><p>Construct a Unified Pseudopotential Format pseudopotential from file.</p><p>Does not support:</p><ul><li>Fully-realtivistic / spin-orbit pseudos</li><li>Bare Coulomb / all-electron potentials</li><li>Semilocal potentials</li><li>Ultrasoft potentials</li><li>Projector-augmented wave potentials</li><li>GIPAW reconstruction data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspUpf.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.RealFourierOperator" href="#DFTK.RealFourierOperator"><code>DFTK.RealFourierOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Linear operators that act on tuples (real, fourier) The main entry point is <code>apply!(out, op, in)</code> which performs the operation out += op*in where out and in are named tuples (real, fourier) They also implement mul! and Matrix(op) for exploratory use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.RealSpaceMultiplication" href="#DFTK.RealSpaceMultiplication"><code>DFTK.RealSpaceMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Real space multiplication by a potential: (Hψ)(r) = V(r) ψ(r).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/operators.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.SimpleMixing" href="#DFTK.SimpleMixing"><code>DFTK.SimpleMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple mixing: <span>$J^{-1} ≈ 1$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.TermNoop" href="#DFTK.TermNoop"><code>DFTK.TermNoop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with a constant zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/terms.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Xc" href="#DFTK.Xc"><code>DFTK.Xc</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Exchange-correlation term, defined by a list of functionals and usually evaluated through libxc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/xc.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.χ0Mixing" href="#DFTK.χ0Mixing"><code>DFTK.χ0Mixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Generic mixing function using a model for the susceptibility composed of the sum of the <code>χ0terms</code>. For valid <code>χ0terms</code> See the subtypes of <code>χ0Model</code>. The dielectric model is solved in real space using a GMRES. Either the full kernel (<code>RPA=false</code>) or only the Hartree kernel (<code>RPA=true</code>) are employed. <code>verbose=true</code> lets the GMRES run in verbose mode (useful for debugging).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.fft!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>fft!</code>. NOTE: If <code>kpt</code> is given, not only <code>f_fourier</code> but also <code>f_real</code> is overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}" href="#AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_real)</code></pre><p>Perform an FFT to obtain the Fourier representation of <code>f_real</code>. If <code>kpt</code> is given, the coefficients are truncated to the k-dependent spherical basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.ifft!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>ifft</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}" href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>AbstractFFTs.ifft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_fourier)</code></pre><p>Perform an iFFT to obtain the quantity defined by <code>f_fourier</code> defined on the k-dependent spherical basis set (if <code>kpt</code> is given) or the k-independent cubic (if it is not) on the real-space grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.atomic_symbol-Tuple{DFTK.Element}" href="#AtomsBase.atomic_symbol-Tuple{DFTK.Element}"><code>AtomsBase.atomic_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Chemical symbol corresponding to an element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.atomic_system" href="#AtomsBase.atomic_system"><code>AtomsBase.atomic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atomic_system(model::DFTK.Model, magnetic_moments=[])
atomic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/atomsbase.jl#L65-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.periodic_system" href="#AtomsBase.periodic_system"><code>AtomsBase.periodic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">periodic_system(model::DFTK.Model, magnetic_moments=[])
periodic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/atomsbase.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Brillouin.KPaths.irrfbz_path-Tuple{Any}" href="#Brillouin.KPaths.irrfbz_path-Tuple{Any}"><code>Brillouin.KPaths.irrfbz_path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the high-symmetry <span>$k$</span>-point path corresponding to the passed <code>model</code> using <code>Brillouin</code>. Uses the conventions described in the reference work by Cracknell, Davies, Miller, and Love (CDML). Of note, this has minor differences to the <span>$k$</span>-path reference (<a href="https://doi.org/10.1016/j.commatsci.2016.10.015">Y. Himuma et. al. Comput. Mater. Sci. <strong>128</strong>, 140 (2017)</a>) underlying the path-choices of <code>Brillouin.jl</code>, specifically for oA and mC Bravais types.</p><p>If the cell is a supercell of a smaller primitive cell, the standard <span>$k$</span>-path of the associated primitive cell is returned. So, the high-symmetry <span>$k$</span> points are those of the primitive cell Brillouin zone, not those of the supercell Brillouin zone.</p><p>The <code>dim</code> argument allows to artificially truncate the dimension of the employed model, e.g. allowing to plot a 2D bandstructure of a 3D model (useful for example for plotting band structures of sheets with <code>dim=2</code>).</p><p>Due to lacking support in <code>Spglib.jl</code> for two-dimensional lattices it is (a) assumed that <code>model.lattice</code> is a <em>conventional</em> lattice and (b) required to pass the space group number using the <code>sgnum</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/band_structure.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.CROP" href="#DFTK.CROP"><code>DFTK.CROP</code></a> — <span class="docstring-category">Function</span></header><section><div><p>CROP-accelerated root-finding iteration for <code>f</code>, starting from <code>x0</code> and keeping a history of <code>m</code> steps. Optionally <code>warming</code> specifies the number of non-accelerated steps to perform for warming up the history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_solvers.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors(basis::PlaneWaveBasis)
G_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of wave vectors <span>$G$</span> in reduced (integer) coordinates of a <code>basis</code> or a <span>$k$</span>-point <code>kpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L384-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}" href="#DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors([architecture=AbstractArchitecture], fft_size::Tuple)</code></pre><p>The wave vectors <code>G</code> in reduced (integer) coordinates for a cubic basis set of given sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L359-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors_cart(basis::PlaneWaveBasis)
G_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G$</span> vectors of a given <code>basis</code> or <code>kpt</code>, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L396-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_in_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maps all <span>$k+G$</span> vectors of an given basis as <span>$G$</span> vectors of the supercell basis, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/supercell.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.HybridMixing-Tuple{}" href="#DFTK.HybridMixing-Tuple{}"><code>DFTK.HybridMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D) \\
    &amp;+ \sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}
\end{aligned}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states and the same convention for parameters are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Additionally there is the real-space localization function <code>L(r)</code>. For details see Herbst, Levitt 2020 arXiv:2009.01665</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L146-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.IncreaseMixingTemperature-Tuple{}" href="#DFTK.IncreaseMixingTemperature-Tuple{}"><code>DFTK.IncreaseMixingTemperature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Increase the temperature used for computing the SCF preconditioners. Initially the temperature is increased by a <code>factor</code>, which is then smoothly lowered towards the temperature used within the model as the SCF converges. Once the density change is below <code>above_ρdiff</code> the mixing temperature is equal to the model temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LdosMixing-Tuple{}" href="#DFTK.LdosMixing-Tuple{}"><code>DFTK.LdosMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)
\end{aligned}\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665.</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/mixing.jl#L174-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfAcceptImprovingStep-Tuple{}" href="#DFTK.ScfAcceptImprovingStep-Tuple{}"><code>DFTK.ScfAcceptImprovingStep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Accept a step if the energy is at most increasing by <code>max_energy</code> and the residual is at most <code>max_relative_residual</code> times the residual in the previous step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/potential_mixing.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceDensity-Tuple{Any}" href="#DFTK.ScfConvergenceDensity-Tuple{Any}"><code>DFTK.ScfConvergenceDensity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence by using the L2Norm of the change between input density and unpreconditioned output density (ρout)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceEnergy-Tuple{Any}" href="#DFTK.ScfConvergenceEnergy-Tuple{Any}"><code>DFTK.ScfConvergenceEnergy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence as soon as total energy change drops below tolerance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceForce-Tuple{Any}" href="#DFTK.ScfConvergenceForce-Tuple{Any}"><code>DFTK.ScfConvergenceForce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence on the change in cartesian force between two iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfDefaultCallback-Tuple{}" href="#DFTK.ScfDefaultCallback-Tuple{}"><code>DFTK.ScfDefaultCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default callback function for <code>self_consistent_field</code> and <code>newton</code>, which prints a convergence table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfDiagtol-Tuple{}" href="#DFTK.ScfDiagtol-Tuple{}"><code>DFTK.ScfDiagtol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the tolerance used for the next diagonalization. This function takes <span>$|ρnext - ρin|$</span> and multiplies it with <code>ratio_ρdiff</code> to get the next <code>diagtol</code>, ensuring additionally that the returned value is between <code>diagtol_min</code> and <code>diagtol_max</code> and never increases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfPlotTrace" href="#DFTK.ScfPlotTrace"><code>DFTK.ScfPlotTrace</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the trace of an SCF, i.e. the absolute error of the total energy at each iteration versus the converged energy in a semilog plot. By default a new plot canvas is generated, but an existing one can be passed and reused along with <code>kwargs</code> for the call to <code>plot!</code>. Requires Plots to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfSaveCheckpoints" href="#DFTK.ScfSaveCheckpoints"><code>DFTK.ScfSaveCheckpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Adds simplistic checkpointing to a DFTK self-consistent field calculation. Requires JLD2 to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_callbacks.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_K-Tuple{PlaneWaveBasis, Vararg{Any, 4}}" href="#DFTK.apply_K-Tuple{PlaneWaveBasis, Vararg{Any, 4}}"><code>DFTK.apply_K</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_K(basis::PlaneWaveBasis, δψ, ψ, ρ, occupation)</code></pre><p>Compute the application of K defined at ψ to δψ. ρ is the density issued from ψ. δψ also generates a δρ, computed with <code>compute_δρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/hessian.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}" href="#DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}"><code>DFTK.apply_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_kernel(basis::PlaneWaveBasis, δρ; kwargs...)</code></pre><p>Computes the potential response to a perturbation δρ in real space, as a 4D (i,j,k,σ) array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/terms.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a symmetry operation to eigenvectors <code>ψk</code> at a given <code>kpoint</code> to obtain an equivalent point in [-0.5, 0.5)^3 and associated eigenvectors (expressed in the basis of the new <span>$k$</span>-point).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a symmetry operation to a density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L271-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}" href="#DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}"><code>DFTK.apply_Ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_Ω(δψ, ψ, H::Hamiltonian, Λ)</code></pre><p>Compute the application of Ω defined at ψ to δψ. H is the Hamiltonian computed from ψ and Λ is the set of Rayleigh coefficients ψk&#39; * Hk * ψk at each k-point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/hessian.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_χ0-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, AbstractArray{T}}} where T" href="#DFTK.apply_χ0-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, AbstractArray{T}}} where T"><code>DFTK.apply_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the density variation δρ corresponding to a potential variation δV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/chi0.jl#L371-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}" href="#DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}"><code>DFTK.attach_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">attach_psp(system::AbstractSystem, pspmap::AbstractDict{Symbol,String})
attach_psp(system::AbstractSystem; psps::String...)</code></pre><p>Return a new system with the <code>pseudopotential</code> property of all atoms set according to the passed <code>pspmap</code>, which maps from the atomic symbol to a pseudopotential identifier. Alternatively the mapping from atomic symbol to pseudopotential identifier can also be passed as keyword arguments. An empty string can be used to denote elements where the full Coulomb potential should be employed.</p><p><strong>Examples</strong></p><p>Select pseudopotentials for all silicon and oxygen atoms in the system.</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Dict(:Si =&gt; &quot;hgh/lda/si-q4&quot;, :O =&gt; &quot;hgh/lda/o-q6&quot;)</code></pre><p>Same thing but using the kwargs syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Si=&quot;hgh/lda/si-q4&quot;, O=&quot;hgh/lda/o-q6&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/attach_psp.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}" href="#DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}"><code>DFTK.build_fft_plans!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plan a FFT of type <code>T</code> and size <code>fft_size</code>, spending some time on finding an optimal algorithm. (Inplace, out-of-place) x (forward, backward) FFT plans are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L255-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_form_factors-Tuple{Any, Array}" href="#DFTK.build_form_factors-Tuple{Any, Array}"><code>DFTK.build_form_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build form factors (Fourier transforms of projectors) for an atom centered at 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/nonlocal.jl#L190-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T" href="#DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T"><code>DFTK.build_projection_vectors_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build projection vectors for a atoms array generated by term_nonlocal</p><p class="math-container">\[\begin{aligned}
H_{\rm at}  &amp;= \sum_{ij} C_{ij} \ket{p_i} \bra{p_j} \\
H_{\rm per} &amp;= \sum_R \sum_{ij} C_{ij} \ket{p_i(x-R)} \bra{p_j(x-R)}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\braket{e_k(G&#39;) \middle| H_{\rm per}}{e_k(G)}
        &amp;= \ldots \\
        &amp;= \frac{1}{Ω} \sum_{ij} C_{ij} \hat p_i(k+G&#39;) \hat p_j^*(k+G),
\end{aligned}\]</p><p>where <span>$\hat p_i(q) = ∫_{ℝ^3} p_i(r) e^{-iq·r} dr$</span>.</p><p>We store <span>$\frac{1}{\sqrt Ω} \hat p_i(k+G)$</span> in <code>proj_vectors</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/nonlocal.jl#L132-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.bzmesh_ir_wedge-Tuple{Any, Any}" href="#DFTK.bzmesh_ir_wedge-Tuple{Any, Any}"><code>DFTK.bzmesh_ir_wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> bzmesh_ir_wedge(kgrid_size, symmetries; kshift=[0, 0, 0])</code></pre><p>Construct the irreducible wedge of a uniform Brillouin zone mesh for sampling <span>$k$</span>-points, given the crystal symmetries <code>symmetries</code>. Returns the list of irreducible <span>$k$</span>-point (fractional) coordinates, the associated weights and the new <code>symmetries</code> compatible with the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.bzmesh_uniform-Tuple{Any}" href="#DFTK.bzmesh_uniform-Tuple{Any}"><code>DFTK.bzmesh_uniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bzmesh_uniform(kgrid_size; kshift=[0, 0, 0])</code></pre><p>Construct a (shifted) uniform Brillouin zone mesh for sampling the <span>$k$</span>-points. Returns all <span>$k$</span>-point coordinates, appropriate weights and the identity SymOp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Tuple{NamedTuple}" href="#DFTK.cell_to_supercell-Tuple{NamedTuple}"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transpose all data from a given self-consistent-field result from unit cell to supercell conventions. The parameters to adapt are the following:</p><ul><li><code>basis_supercell</code> and <code>ψ_supercell</code> are computed by the routines above.</li><li>The supercell occupations vector is the concatenation of all input occupations vectors.</li><li>The supercell density is computed with supercell occupations and <code>ψ_supercell</code>.</li><li>Supercell energies are the multiplication of input energies by the number of unit cells in the supercell.</li></ul><p>Other parameters stay untouched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/supercell.jl#L96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.cell_to_supercell-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a plane-wave basis whose unit cell is the supercell associated to an input basis <span>$k$</span>-grid. All other parameters are modified so that the respective physical systems associated to both basis are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/supercell.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real" href="#DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Re-organize Bloch waves computed in a given basis as Bloch waves of the associated supercell basis. The output <code>ψ_supercell</code> have a single component at <span>$Γ$</span>-point, such that <code>ψ_supercell[Γ][:, k+n]</code> contains <code>ψ[k][:, n]</code>, within normalization on the supercell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/supercell.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T" href="#DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T"><code>DFTK.cg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implementation of the conjugate gradient method which allows for preconditioning and projection operations along iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/cg.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.charge_ionic-Tuple{DFTK.Element}" href="#DFTK.charge_ionic-Tuple{DFTK.Element}"><code>DFTK.charge_ionic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total ionic charge of an atom type (nuclear charge - core electrons)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.charge_nuclear-Tuple{DFTK.Element}" href="#DFTK.charge_nuclear-Tuple{DFTK.Element}"><code>DFTK.charge_nuclear</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total nuclear charge of an atom type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cis2pi-Tuple{Any}" href="#DFTK.cis2pi-Tuple{Any}"><code>DFTK.cis2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute exp(2π i x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/cis2pi.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_Ak_gaussian_guess-Tuple{PlaneWaveBasis, Vararg{Any, 4}}" href="#DFTK.compute_Ak_gaussian_guess-Tuple{PlaneWaveBasis, Vararg{Any, 4}}"><code>DFTK.compute_Ak_gaussian_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the matrix <span>$[A_k]_{m,n} = \langle ψ_m^k | g^{\text{per}}_n \rangle$</span></p><p><span>$g^{per}_n$</span> are periodized gaussians whose respective centers are given as an  (num_bands,1) array [ [center 1], ... ].</p><p>Centers are to be given in lattice coordinates and G_vectors in reduced coordinates. The dot product is computed in the Fourier space.</p><p>Given an orbital <span>$g_n$</span>, the periodized orbital is defined by :  <span>$g^{per}_n =  \sum\limits_{R \in {\rm lattice}} g_n( \cdot - R)$</span>. The  Fourier coefficient of <span>$g^{per}_n$</span> at any G is given by the value of the Fourier transform of <span>$g_n$</span> in G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L187-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the <em>probability</em> (not charge) current, ∑ fn Im(ψn* ∇ψn)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/current.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_density(basis::PlaneWaveBasis, ψ::AbstractVector, occupation::AbstractVector)</code></pre><p>Compute the density for a wave function <code>ψ</code> discretized on the plane-wave grid <code>basis</code>, where the individual k-points are occupied according to <code>occupation</code>. <code>ψ</code> should be one coefficient matrix per <span>$k$</span>-point. It is possible to ask only for occupations higher than a certain level to be computed by using an optional <code>occupation_threshold</code>. By default all occupation numbers are considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/densities.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dos-Tuple{Any, Any, Any}" href="#DFTK.compute_dos-Tuple{Any, Any, Any}"><code>DFTK.compute_dos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Total density of states at energy ε</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/dos.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dynmat-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_dynmat-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_dynmat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the dynamical matrix in the form of a <span>$3×n_{ m atoms}×3×n_{ m atoms}$</span> tensor in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/phonon.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dynmat_cart-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_dynmat_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_dynmat_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cartesian form of <a href="#DFTK.compute_dynmat-Tuple{PlaneWaveBasis, Any, Any}"><code>compute_dynmat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/phonon.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T" href="#DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T"><code>DFTK.compute_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the minimal grid size for the cubic basis set to be able to represent product of orbitals (with the default <code>supersampling=2</code>).</p><p>Optionally optimize the grid afterwards for the FFT procedure by ensuring factorization into small primes.</p><p>The function will determine the smallest parallelepiped containing the wave vectors  <span>$|G|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span>. For an exact representation of the density resulting from wave functions represented in the spherical basis sets, <code>supersampling</code> should be at least <code>2</code>.</p><p>If <code>factors</code> is not empty, ensure that the resulting fft_size contains all the factors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the forces of an obtained SCF solution. Returns the forces wrt. the fractional lattice vectors. To get cartesian forces use <a href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>compute_forces_cart</code></a>. Returns a list of lists of forces (as SVector{3}) in the same order as the <code>atoms</code> and <code>positions</code> in the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/forces.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_forces_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the cartesian forces of an obtained SCF solution in Hartree / Bohr. Returns a list of lists of forces <code>[[force for atom in positions] for (element, positions) in atoms]</code> which has the same structure as the <code>atoms</code> object passed to the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/forces.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_inverse_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the inverse of the lattice. Takes special care of 1D or 2D cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/structure.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.compute_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_kernel(basis::PlaneWaveBasis; kwargs...)</code></pre><p>Computes a matrix representation of the full response kernel (derivative of potential with respect to density) in real space. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks</p><p class="math-container">\[\left(\begin{array}{cc}
    K_{αα} &amp; K_{αβ}\\
    K_{βα} &amp; K_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/terms.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_ldos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local density of states, in real space. <code>weight_threshold</code> is a threshold to screen away small contributions to the LDOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/dos.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute occupation given eigenvalues and Fermi level</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/occupation.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute occupation and Fermi level given eigenvalues and using <code>fermialg</code>. The <code>tol_n_elec</code> gives the accuracy on the electron count which should be at least achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/occupation.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_recip_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the reciprocal lattice. We use the convention that the reciprocal lattice is the set of G vectors such that G ⋅ R ∈ 2π ℤ for all R in the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/structure.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_stresses_cart-Tuple{Any}" href="#DFTK.compute_stresses_cart-Tuple{Any}"><code>DFTK.compute_stresses_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the stresses (= 1/Vol dE/d(M*lattice), taken at M=I) of an obtained SCF solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/stresses.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a sparse matrix that maps quantities given on <code>basis_in</code> and <code>kpt_in</code> to quantities on <code>basis_out</code> and <code>kpt_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a list of sparse matrices (one per <span>$k$</span>-point) that map quantities given in the <code>basis_in</code> basis to quantities given in the <code>basis_out</code> basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L79-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_unit_cell_volume-Tuple{Any}" href="#DFTK.compute_unit_cell_volume-Tuple{Any}"><code>DFTK.compute_unit_cell_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute unit cell volume volume. In case of 1D or 2D case, the volume is the length/surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/structure.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, Any, Any, T, Any, Any}} where T" href="#DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, Any, Any, T, Any, Any}} where T"><code>DFTK.compute_δocc!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the derivatives of the occupations (and of the Fermi level). The derivatives of the occupations are in-place stored in δocc. The tuple (; δocc, δεF) is returned. It is assumed the passed <code>δocc</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/chi0.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_δψ!-NTuple{7, Any}" href="#DFTK.compute_δψ!-NTuple{7, Any}"><code>DFTK.compute_δψ!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform in-place computations of the derivatives of the wave functions by solving a Sternheimer equation for each <code>k</code>-points. It is assumed the passed <code>δψ</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/chi0.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_χ0-Tuple{Any}" href="#DFTK.compute_χ0-Tuple{Any}"><code>DFTK.compute_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the independent-particle susceptibility. Will blow up for large systems. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks, which are:</p><p class="math-container">\[\left(\begin{array}{cc}
    (χ_0)_{αα}  &amp; (χ_0)_{αβ} \\
    (χ_0)_{βα}  &amp; (χ_0)_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/chi0.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cos2pi-Tuple{Any}" href="#DFTK.cos2pi-Tuple{Any}"><code>DFTK.cos2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute cos(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/cis2pi.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{Any, Any}" href="#DFTK.count_n_proj-Tuple{Any, Any}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psps, psp_positions)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code> and for all atoms in the system, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp, l)</code></pre><p>Number of projector functions for angular momentum <code>l</code>, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code>, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(psp, l)</code></pre><p>Number of projector radial functions at angular momentum <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(psp)</code></pre><p>Number of projector radial functions at all angular momenta up to <code>psp.lmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.create_supercell-NTuple{4, Any}" href="#DFTK.create_supercell-NTuple{4, Any}"><code>DFTK.create_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a supercell of size <code>supercell_size</code> from a unit cell described by its <code>lattice</code>, <code>atoms</code> and their <code>positions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/supercell.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.datadir_psp-Tuple{}" href="#DFTK.datadir_psp-Tuple{}"><code>DFTK.datadir_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the data directory with pseudopotential files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/load_psp.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}" href="#DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}"><code>DFTK.default_fermialg</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default selection of a Fermi level determination algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/occupation.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_symmetries-NTuple{6, Any}" href="#DFTK.default_symmetries-NTuple{6, Any}"><code>DFTK.default_symmetries</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default logic to determine the symmetry operations to be used in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L254-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_wannier_centres-Tuple{Any}" href="#DFTK.default_wannier_centres-Tuple{Any}"><code>DFTK.default_wannier_centres</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default random Gaussian guess for maximally-localised wannier functions generated in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L244-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.determine_spin_polarization-Tuple{Any}" href="#DFTK.determine_spin_polarization-Tuple{Any}"><code>DFTK.determine_spin_polarization</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>:none</code> if no element has a magnetic moment, else <code>:collinear</code> or <code>:full</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}" href="#DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}"><code>DFTK.diagonalize_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function for diagonalising each <span>$k$</span>-Point blow of ham one step at a time. Some logic for interpolating between <span>$k$</span>-points is used if <code>interpolate_kpoints</code> is true and if no guesses are given. <code>eigensolver</code> is the iterative eigensolver that really does the work, operating on a single <span>$k$</span>-Block. <code>eigensolver</code> should support the API <code>eigensolver(A, X0; prec, tol, maxiter)</code> <code>prec_type</code> should be a function that returns a preconditioner when called as <code>prec(ham, kpt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/eigen/diag.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.diameter-Tuple{AbstractMatrix}" href="#DFTK.diameter-Tuple{AbstractMatrix}"><code>DFTK.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the diameter of the unit cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/structure.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.direct_minimization-Tuple{PlaneWaveBasis}" href="#DFTK.direct_minimization-Tuple{PlaneWaveBasis}"><code>DFTK.direct_minimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the ground state by direct minimization. <code>kwargs...</code> are passed to <code>Optim.Options()</code>. Note that the resulting ψ are not necessarily eigenvectors of the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/direct_minimization.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.disable_threading-Tuple{}" href="#DFTK.disable_threading-Tuple{}"><code>DFTK.disable_threading</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience function to disable all threading in DFTK and assert that Julia threading is off as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/threading.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.divergence_real-Tuple{Any, Any}" href="#DFTK.divergence_real-Tuple{Any, Any}"><code>DFTK.divergence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute divergence of an operand function, which returns the cartesian x,y,z components in real space when called with the arguments 1 to 3. The divergence is also returned as a real-space array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/xc.jl#L508-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard computation of energy and forces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/ewald.jl#L33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation for phonons; required to build the dynamical matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/ewald.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the electrostatic energy and forces. The energy is the electrostatic interaction energy per unit cell between point charges in a uniform background of compensating charge to yield net neutrality. The forces is the opposite of the derivative of the energy with respect to <code>positions</code>.</p><p><code>lattice</code> should contain the lattice vectors as columns. <code>charges</code> and <code>positions</code> are the point charges and their positions (as an array of arrays) in fractional coordinates.</p><p>For now this function returns zero energy and force on non-3D systems. Use a pairwise potential term if you want to customise this treatment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/ewald.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard computation of energy and forces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/pairwise.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 6}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 6}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation for phonons; required to build the dynamical matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/pairwise.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 6}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 6}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the pairwise energy and forces. The energy is the interaction energy per unit cell between atomic sites. The forces is the opposite of the derivative of the energy with respect to <code>positions</code>.</p><p><code>lattice</code> should contain the lattice vectors as columns. <code>symbols</code> and <code>positions</code> are the atomic elements and their positions (as an array of arrays) in fractional coordinates. <code>V</code> and <code>params</code> are the pairwise potential and its set of parameters (that depends on pairs of symbols).</p><p>The potential is expected to decrease quickly at infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/pairwise.jl#L69-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.energy_psp_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the correction term for properly modelling the interaction of the pseudopotential core with the compensating background charge induced by the <code>Ewald</code> term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/psp_correction.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.enforce_real!-Tuple{Any, Any}" href="#DFTK.enforce_real!-Tuple{Any, Any}"><code>DFTK.enforce_real!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Ensure its real-space equivalent of passed Fourier-space representation is entirely real by removing wavevectors <code>G</code> that don&#39;t have a <code>-G</code> counterpart in the basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L467-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.estimate_integer_lattice_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate integer bounds for dense space loops from a given inequality ||Mx|| ≤ δ. For 1D and 2D systems the limit will be zero in the auxiliary dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/structure.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_core_fourier-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real" href="#DFTK.eval_psp_density_core_fourier-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real"><code>DFTK.eval_psp_density_core_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_core_fourier(psp, q)</code></pre><p>Evaluate the atomic core charge density in reciprocal space: ρval(q) = ∫<em>{R^3} ρcore(r) e^{-iqr} dr         = 4π ∫</em>{R+} ρcore(r) sin(qr)/qr r^2 dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_core_real-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real" href="#DFTK.eval_psp_density_core_real-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real"><code>DFTK.eval_psp_density_core_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_core_real(psp, r)</code></pre><p>Evaluate the atomic core charge density in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_valence_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_density_valence_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_density_valence_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_valence_fourier(psp, q)</code></pre><p>Evaluate the atomic valence charge density in reciprocal space: ρval(q) = ∫<em>{R^3} ρval(r) e^{-iqr} dr         = 4π ∫</em>{R+} ρval(r) sin(qr)/qr r^2 dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_valence_real-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_density_valence_real-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_density_valence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_valence_real(psp, r)</code></pre><p>Evaluate the atomic valence charge density in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_energy_correction" href="#DFTK.eval_psp_energy_correction"><code>DFTK.eval_psp_energy_correction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_psp_energy_correction([T=Float64,] psp, n_electrons)</code></pre><p>Evaluate the energy correction to the Ewald electrostatic interaction energy of one unit cell, which is required compared the Ewald expression for point-like nuclei. <code>n_electrons</code> is the number of electrons per unit cell. This defines the uniform compensating background charge, which is assumed here.</p><p>Notice: The returned result is the <em>energy per unit cell</em> and not the energy per volume. To obtain the latter, the caller needs to divide by the unit cell volume.</p><p>The energy correction is defined as the limit of the Fourier-transform of the local potential as <span>$q \to 0$</span>, using the same correction as in the Fourier-transform of the local potential: <code>math \lim_{q \to 0} 4π N_{\rm elec} ∫_{ℝ_+} (V(r) - C(r)) \frac{\sin(qr)}{qr} r^2 dr + F[C(r)]  = 4π N_{\rm elec} ∫_{ℝ_+} (V(r) + Z/r) r^2 dr</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L83-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_fourier(psp, q)</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space:</p><p class="math-container">\[\begin{aligned}
V_{\rm loc}(q) &amp;= ∫_{ℝ^3} V_{\rm loc}(r) e^{-iqr} dr \\
               &amp;= 4π ∫_{ℝ_+} V_{\rm loc}(r) \frac{\sin(qr)}{q} r dr
\end{aligned}\]</p><p>In practice, the local potential should be corrected using a Coulomb-like term <span>$C(r) = -Z/r$</span> to remove the long-range tail of <span>$V_{\rm loc}(r)$</span> from the integral:</p><p class="math-container">\[\begin{aligned}
V_{\rm loc}(q) &amp;= ∫_{ℝ^3} (V_{\rm loc}(r) - C(r)) e^{-iq·r} dr + F[C(r)] \\
               &amp;= 4π ∫_{ℝ_+} (V_{\rm loc}(r) + Z/r) \frac{\sin(qr)}{qr} r^2 dr - Z/q^2
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L61-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_projector_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_fourier(psp, i, l, q)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal vector with modulus <code>q</code>:</p><p class="math-container">\[\begin{aligned}
p(q) &amp;= ∫_{ℝ^3} p_{il}(r) e^{-iq·r} dr \\
     &amp;= 4π ∫_{ℝ_+} r^2 p_{il}(r) j_l(qr) dr
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}" href="#DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}"><code>DFTK.eval_psp_projector_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_real(psp, i, l, r)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> in real-space at the vector with modulus <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/NormConservingPsp.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.filled_occupation-Tuple{Any}" href="#DFTK.filled_occupation-Tuple{Any}"><code>DFTK.filled_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maximal occupation of a state (2 for non-spin-polarized electrons, 1 otherwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L281-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.find_equivalent_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the equivalent index of the coordinate <code>kcoord</code> ∈ ℝ³ in a list <code>kcoords</code> ∈ [-½, ½)³. <code>ΔG</code> is the vector of ℤ³ such that <code>kcoords[index] = kcoord + ΔG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L183-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gather_kpts-Tuple{AbstractArray, PlaneWaveBasis}" href="#DFTK.gather_kpts-Tuple{AbstractArray, PlaneWaveBasis}"><code>DFTK.gather_kpts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gather the distributed data of a quantity depending on <code>k</code>-Points on the master process and return it. On the other (non-master) processes <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L534-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gather_kpts-Tuple{PlaneWaveBasis}" href="#DFTK.gather_kpts-Tuple{PlaneWaveBasis}"><code>DFTK.gather_kpts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gather the distributed <span>$k$</span>-point data on the master process and return it as a <code>PlaneWaveBasis</code>. On the other (non-master) processes <code>nothing</code> is returned. The returned object should not be used for computations and only to extract data for post-processing and serialisation to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L498-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gaussian_valence_charge_density_fourier-Union{Tuple{T}, Tuple{DFTK.Element, T}} where T&lt;:Real" href="#DFTK.gaussian_valence_charge_density_fourier-Union{Tuple{T}, Tuple{DFTK.Element, T}} where T&lt;:Real"><code>DFTK.gaussian_valence_charge_density_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gaussian valence charge density using Abinit&#39;s coefficient table, in Fourier space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.guess_density" href="#DFTK.guess_density"><code>DFTK.guess_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">guess_density(basis::PlaneWaveBasis, method::DensityConstructionMethod,
              magnetic_moments=[]; n_electrons=basis.model.n_electrons)</code></pre><p>Build a superposition of atomic densities (SAD) guess density or a rarndom guess density.</p><p>The guess atomic densities are taken as one of the following depending on the input <code>method</code>:</p><p>-<code>RandomDensity()</code>: A random density, normalized to the number of electrons <code>basis.model.n_electrons</code>. Does not support magnetic moments. -<code>ValenceDensityAuto()</code>: A combination of the <code>ValenceDensityGaussian</code> and <code>ValenceDensityPseudo</code> methods where elements whose pseudopotentials provide numeric valence charge density data use them and elements without use Gaussians. -<code>ValenceDensityGaussian()</code>: Gaussians of length specified by <code>atom_decay_length</code> normalized for the correct number of electrons:</p><p class="math-container">\[\hat{ρ}(G) = Z_{\mathrm{valence}} \exp\left(-(2π \text{length} |G|)^2\right)\]</p><ul><li><code>ValenceDensityPseudo()</code>: Numerical pseudo-atomic valence charge densities from the</li></ul><p>pseudopotentials. Will fail if one or more elements in the system has a pseudopotential that does not have valence charge density data.</p><p>When magnetic moments are provided, construct a symmetry-broken density guess. The magnetic moments should be specified in units of <span>$μ_B$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/density_methods.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}" href="#DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}"><code>DFTK.hamiltonian_with_total_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a new Hamiltonian with local potential replaced by the given one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/Hamiltonian.jl#L226-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.hankel-Union{Tuple{T}, Tuple{AbstractVector, AbstractVector, Integer, T}} where T&lt;:Real" href="#DFTK.hankel-Union{Tuple{T}, Tuple{AbstractVector, AbstractVector, Integer, T}} where T&lt;:Real"><code>DFTK.hankel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hankel(r, r2_f, l, q)</code></pre><p>Compute the Hankel transform</p><p class="math-container">\[    H[f] = 4\pi \int_0^\infty r f(r) j_l(qr) r dr.\]</p><p>The integration is performed by trapezoidal quadrature, and the function takes as input the radial grid <code>r</code>, the precomputed quantity r²f(r) <code>r2_f</code>, angular momentum / spherical bessel order <code>l</code>, and the Hankel coordinate <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/hankel.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.has_core_density-Tuple{DFTK.Element}" href="#DFTK.has_core_density-Tuple{DFTK.Element}"><code>DFTK.has_core_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check presence of model core charge density (non-linear core correction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}" href="#DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}"><code>DFTK.index_G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the index tuple <code>I</code> such that <code>G_vectors(basis)[I] == G</code> or the index <code>i</code> such that <code>G_vectors(basis, kpoint)[i] == G</code>. Returns nothing if outside the range of valid wave vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L443-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}" href="#DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}"><code>DFTK.interpolate_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate a function expressed in a basis <code>basis_in</code> to a basis <code>basis_out</code>. This interpolation uses a very basic real-space algorithm, and makes a DWIM-y attempt to take into account the fact that <code>basis_out</code> can be a supercell of <code>basis_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/interpolation.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}" href="#DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}"><code>DFTK.interpolate_kpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate some data from one <span>$k$</span>-point to another. The interpolation is fast, but not necessarily exact. Intended only to construct guesses for iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/interpolation.jl#L82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T" href="#DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T"><code>DFTK.irfft</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a real valued iFFT; see <a href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>ifft</code></a>. Note that this function silently drops the imaginary part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L62-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.is_metal-Tuple{Any, Any}" href="#DFTK.is_metal-Tuple{Any, Any}"><code>DFTK.is_metal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_metal(eigenvalues, εF; tol)</code></pre><p>Determine whether the provided bands indicate the material is a metal, i.e. where bands are cut by the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/band_structure.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.k_to_kpq_mapping-Tuple{PlaneWaveBasis, Any}" href="#DFTK.k_to_kpq_mapping-Tuple{PlaneWaveBasis, Any}"><code>DFTK.k_to_kpq_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the indices of the <code>kpoints</code> shifted by <code>q</code>. That is for each <code>kpoint</code> of the <code>basis</code>: <code>kpoints[ik].coordinate + q = kpoints[indices[ik]].coordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L217-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kcoords_monkhorst_pack-Tuple{Any}" href="#DFTK.kcoords_monkhorst_pack-Tuple{Any}"><code>DFTK.kcoords_monkhorst_pack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the coordinates of the <span>$k$</span>-points in a (shifted) Monkorst-Pack grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}" href="#DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}"><code>DFTK.kgrid_from_minimal_n_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Selects a kgrid size which ensures that at least a <code>n_kpoints</code> total number of <span>$k$</span>-points are used. The distribution of <span>$k$</span>-points amongst coordinate directions is as uniformly as possible, trying to achieve an identical minimal spacing in all directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kgrid_from_minimal_spacing-Tuple{Any, Any}" href="#DFTK.kgrid_from_minimal_spacing-Tuple{Any, Any}"><code>DFTK.kgrid_from_minimal_spacing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Selects a kgrid size to ensure a minimal spacing (in inverse Bohrs) between kpoints. A reasonable spacing is <code>0.13</code> inverse Bohrs (around <span>$2π * 0.04 \AA^{-1}$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L103-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D" href="#DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D"><code>DFTK.kpath_get_kcoords</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return kpoint coordinates in reduced coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/band_structure.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}" href="#DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}"><code>DFTK.krange_spin</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the index range of <span>$k$</span>-points that have a particular spin component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L479-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.list_psp" href="#DFTK.list_psp"><code>DFTK.list_psp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">list_psp(element; functional, family, core)</code></pre><p>List the pseudopotential files known to DFTK. Allows various ways to restrict the displayed files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(family=&quot;hgh&quot;)</code></pre><p>will list all HGH-type pseudopotentials and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(family=&quot;hgh&quot;, functional=&quot;lda&quot;)</code></pre><p>will only list those for LDA (also known as Pade in this context) and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(:O, core=:semicore)</code></pre><p>will list all oxygen semicore pseudopotentials known to DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/list_psp.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.load_psp-Tuple{AbstractString}" href="#DFTK.load_psp-Tuple{AbstractString}"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>datadir_psp()</code> and by the <code>key</code>. If the <code>key</code> is a path to a valid file, the extension is used to determine the type of the pseudopotential file format and a respective class is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/load_psp.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.load_scfres" href="#DFTK.load_scfres"><code>DFTK.load_scfres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_scfres(filename)</code></pre><p>Load back an <code>scfres</code>, which has previously been stored with <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>. Note the warning in <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scfres.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}" href="#DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}"><code>DFTK.model_DFT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a DFT model from the specified atoms, with the specified functionals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/standard_models.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_LDA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an LDA model (Perdew &amp; Wang parametrization) from the specified atoms. DOI:10.1103/PhysRevB.45.13244</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/standard_models.jl#L48-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_PBE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an PBE-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.77.3865</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/standard_models.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_SCAN</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a SCAN meta-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.115.036402</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/standard_models.jl#L68-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_atomic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience constructor, which builds a standard atomic (kinetic + atomic potential) model. Use <code>extra_terms</code> to add additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/standard_models.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.mpi_nprocs" href="#DFTK.mpi_nprocs"><code>DFTK.mpi_nprocs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Number of processors used in MPI. Can be called without ensuring initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/mpi.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.multiply_by_expiqr-NTuple{4, Any}" href="#DFTK.multiply_by_expiqr-NTuple{4, Any}"><code>DFTK.multiply_by_expiqr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the Fourier coefficients for <code>ψk · e^{i q·r}</code> in the basis of <code>kpt_out</code>, where <code>ψk</code> is defined on a basis <code>kpt_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L206-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_elec_core-Tuple{DFTK.Element}" href="#DFTK.n_elec_core-Tuple{DFTK.Element}"><code>DFTK.n_elec_core</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of core electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_elec_valence-Tuple{DFTK.Element}" href="#DFTK.n_elec_valence-Tuple{DFTK.Element}"><code>DFTK.n_elec_valence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of valence electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/elements.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_electrons_from_atoms-Tuple{Any}" href="#DFTK.n_electrons_from_atoms-Tuple{Any}"><code>DFTK.n_electrons_from_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of valence electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T" href="#DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T"><code>DFTK.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton(basis::PlaneWaveBasis{T}, ψ0;
       tol=1e-6, tol_cg=tol / 100, maxiter=20, callback=ScfDefaultCallback(),
       is_converged=ScfConvergenceDensity(tol))</code></pre><p>Newton algorithm. Be careful that the starting point needs to be not too far from the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/newton.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.next_compatible_fft_size-Tuple{Int64}" href="#DFTK.next_compatible_fft_size-Tuple{Int64}"><code>DFTK.next_compatible_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the next compatible FFT size Sizes must (a) be a product of small primes only and (b) contain the factors. If smallprimes is empty (a) is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/fft.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.next_density" href="#DFTK.next_density"><code>DFTK.next_density</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain new density ρ by diagonalizing <code>ham</code>. Follows the policy imposed by the <code>bands</code> data structure to determine and adjust the number of bands to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/self_consistent_field.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.norm2-Tuple{Any}" href="#DFTK.norm2-Tuple{Any}"><code>DFTK.norm2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Square of the ℓ²-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/norm.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.norm_cplx-Tuple{Any}" href="#DFTK.norm_cplx-Tuple{Any}"><code>DFTK.norm_cplx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Complex-analytic extension of <code>LinearAlgebra.norm(x)</code> from real to complex inputs. Needed for phonons as we want to perform a matrix-vector product <code>f&#39;(x)·h</code>, where <code>f</code> is a real-to-real function and <code>h</code> a complex vector. To do this using automatic differentiation, we can extend analytically f to accept complex inputs, then differentiate <code>t -&gt; f(x+t·h)</code>. This will fail if non-analytic functions like norm are used for complex inputs, and therefore we have to redefine it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/norm.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.normalize_kpoint_coordinate-Tuple{Real}" href="#DFTK.normalize_kpoint_coordinate-Tuple{Real}"><code>DFTK.normalize_kpoint_coordinate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bring <span>$k$</span>-point coordinates into the range [-0.5, 0.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/bzmesh.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Vararg{Any, 5}}" href="#DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Vararg{Any, 5}}"><code>DFTK.overlap_Mmn_k_kpb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the matrix <span>$[M^{k,b}]_{m,n} = \langle u_{m,k} | u_{n,k+b} \rangle$</span> for given <code>k</code>, <code>kpb</code> = <span>$k+b$</span>.</p><p><code>G_shift</code> is the &quot;shifting&quot; vector, correction due to the periodicity conditions imposed on <span>$k \to  ψ_k$</span>. It is non zero if <code>kpb</code> is taken in another unit cell of the reciprocal lattice. We use here that: <span>$u_{n(k + G_{\rm shift})}(r) = e^{-i*\langle G_{\rm shift},r \rangle} u_{nk}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.plot_bandstructure" href="#DFTK.plot_bandstructure"><code>DFTK.plot_bandstructure</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute and plot the band structure. <code>n_bands</code> selects the number of bands to compute. If this value is absent and an <code>scfres</code> is used to start the calculation a default of <code>n_bands_scf + 5sqrt(n_bands_scf)</code> is used. The unit used to plot the bands can be selected using the <code>unit</code> parameter. Like in the rest of DFTK Hartree is used by default. Another standard choices is <code>unit=u&quot;eV&quot;</code> (electron volts). The <code>kline_density</code> is given in number of <span>$k$</span>-points per inverse bohrs (i.e. overall in units of length).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/band_structure.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.plot_dos" href="#DFTK.plot_dos"><code>DFTK.plot_dos</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the density of states over a reasonable range. Requires to load <code>Plots.jl</code> beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/postprocess/dos.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.psp_local_polynomial" href="#DFTK.psp_local_polynomial"><code>DFTK.psp_local_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The local potential of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) / (t^2 exp(t^2 / 2))$</span> where <span>$t = r_\text{loc} q$</span> and <code>Q</code> is a polynomial of at most degree 8. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspHgh.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.psp_projector_polynomial" href="#DFTK.psp_projector_polynomial"><code>DFTK.psp_projector_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The nonlocal projectors of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) exp(-t^2 / 2)$</span> where <span>$t = r_l q$</span> and <code>Q</code> is a polynomial. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspHgh.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T" href="#DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T"><code>DFTK.qcut_psp_local</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>abs(eval_psp_local_fourier(psp, q))</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspHgh.jl#L136-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T" href="#DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T"><code>DFTK.qcut_psp_projector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>eval_psp_projector_fourier(psp, q)</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/pseudo/PspHgh.jl#L193-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.r_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in reduced coordinates. By convention, this is in [0,1)^3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors_cart(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.random_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Integer}} where T" href="#DFTK.random_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Integer}} where T"><code>DFTK.random_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a random charge density normalized to the provided number of electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/density_methods.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.read_w90_nnkp-Tuple{String}" href="#DFTK.read_w90_nnkp-Tuple{String}"><code>DFTK.read_w90_nnkp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read the .nnkp file provided by the preprocessing routine of Wannier90 (i.e. &quot;wannier90.x -pp prefix&quot;) Returns:</p><ol><li>the array &#39;nnkpts&#39; of k points, their respective nearest neighbors and associated shifing vectors (non zero if the neighbor is located in another cell).</li><li>the number &#39;nntot&#39; of neighbors per k point.</li></ol><p>TODO: add the possibility to exclude bands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.run_wannier90" href="#DFTK.run_wannier90"><code>DFTK.run_wannier90</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Wannerize the obtained bands using wannier90. By default all converged bands from the <code>scfres</code> are employed (change with <code>n_bands</code> kwargs) and <code>n_wannier = n_bands</code> wannier functions are computed using random Gaussians as guesses. All keyword arguments supported by Wannier90 for the disentanglement may be added as keyword arguments. The function returns the <code>fileprefix</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental feature</header><div class="admonition-body"><p>Currently this is an experimental feature, which has not yet been tested to full depth. The interface is considered unstable and may change incompatibly in the future. Use at your own risk and please report bugs in case you encounter any.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/stubs.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.save_scfres-Tuple{AbstractString, NamedTuple}" href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>DFTK.save_scfres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_scfres(filename, scfres)</code></pre><p>Save an <code>scfres</code> obtained from <code>self_consistent_field</code> to a file. The format is determined from the file extension. Currently the following file extensions are recognized and supported:</p><ul><li><strong>jld2</strong>: A JLD2 file. Stores the complete state and can be used (with <a href="#DFTK.load_scfres"><code>load_scfres</code></a>) to restart an SCF from a checkpoint or post-process an SCF solution. See <a href="../tricks/scf_checkpoints/#Saving-SCF-results-on-disk-and-SCF-checkpoints">Saving SCF results on disk and SCF checkpoints</a> for details.</li><li><strong>vts</strong>: A VTK file for visualisation e.g. in <a href="https://www.paraview.org/">paraview</a>. Stores the density, spin density and some metadata (energy, Fermi level, occupation etc.). Supports these keyword arguments:<ul><li><code>save_ψ</code>: Save the real-space representation of the orbitals as well (may lead to larger files).</li><li><code>extra_data</code>: <code>Dict{String,Array}</code> with additional data on the 3D real-space grid to store into the VTK file.</li></ul></li><li><strong>json</strong>: A JSON file with basic information about the SCF run. Stores for example  the number of iterations, occupations, norm of the most recent density change,  eigenvalues, Fermi level etc.</li></ul><div class="admonition is-warning"><header class="admonition-header">No compatibility guarantees</header><div class="admonition-body"><p>No guarantees are made with respect to this function at this point. It may change incompatibly between DFTK versions or stop working / be removed in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scfres.jl#L30-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_anderson_solver" href="#DFTK.scf_anderson_solver"><code>DFTK.scf_anderson_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a simple anderson-accelerated SCF solver. <code>m</code> specifies the number of steps to keep the history of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_solvers.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_damping_quadratic_model-Tuple{Any, Any}" href="#DFTK.scf_damping_quadratic_model-Tuple{Any, Any}"><code>DFTK.scf_damping_quadratic_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use the two iteration states <code>info</code> and <code>info_next</code> to find a damping value from a quadratic model for the SCF energy. Returns <code>nothing</code> if the constructed model is not considered trustworthy, else returns the suggested damping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/potential_mixing.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_damping_solver" href="#DFTK.scf_damping_solver"><code>DFTK.scf_damping_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a damped SCF solver updating the density as <code>x = β * x_new + (1 - β) * x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/scf_solvers.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}" href="#DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}"><code>DFTK.select_eigenpairs_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to select a subset of eigenpairs on each <span>$k$</span>-Point. Works on the Tuple returned by <code>diagonalize_all_kblocks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/eigen/diag.jl#L75-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.self_consistent_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">self_consistent_field(basis; [tol, mixing, damping, ρ, ψ])</code></pre><p>Solve the Kohn-Sham equations with a density-based SCF algorithm using damped, preconditioned iterations where <span>$ρ_\text{next} = α P^{-1} (ρ_\text{out} - ρ_\text{in})$</span>.</p><p>Overview of parameters:</p><ul><li><code>ρ</code>:   Initial density</li><li><code>ψ</code>:   Initial orbitals</li><li><code>tol</code>: Tolerance for the density change (<span>$\|ρ_\text{out} - ρ_\text{in}\|$</span>) to flag convergence. Default is <code>1e-6</code>.</li><li><code>is_converged</code>: Convergence control callback. Typical objects passed here are <code>DFTK.ScfConvergenceDensity(tol)</code> (the default), <code>DFTK.ScfConvergenceEnergy(tol)</code> or <code>DFTK.ScfConvergenceForce(tol)</code>.</li><li><code>maxiter</code>: Maximal number of SCF iterations</li><li><code>mixing</code>: Mixing method, which determines the preconditioner <span>$P^{-1}$</span> in the above equation. Typical mixings are <a href="#DFTK.LdosMixing-Tuple{}"><code>LdosMixing</code></a>, <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, <a href="#DFTK.SimpleMixing"><code>SimpleMixing</code></a> or <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Default is <code>LdosMixing()</code></li><li><code>damping</code>: Damping parameter <span>$α$</span> in the above equation. Default is <code>0.8</code>.</li><li><code>nbandsalg</code>: By default DFTK uses <code>nbandsalg=AdaptiveBands(model)</code>, which adaptively determines the number of bands to compute. If you want to influence this algorithm or use a predefined number of bands in each SCF step, pass a <a href="#DFTK.FixedBands"><code>FixedBands</code></a> or <a href="#DFTK.AdaptiveBands"><code>AdaptiveBands</code></a>. Beware that with non-zero temperature, the convergence of the SCF algorithm may be limited by the <code>default_occupation_threshold()</code> parameter. For highly accurate calculations we thus recommend increasing the <code>occupation_threshold</code> of the <code>AdaptiveBands</code>.</li><li><code>callback</code>: Function called at each SCF iteration. Usually takes care of printing the intermediate state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/scf/self_consistent_field.jl#L58-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.simpson" href="#DFTK.simpson"><code>DFTK.simpson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simpson(x, y)</code></pre><p>Integrate y(x) over x using Simpson&#39;s method quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/quadrature.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.sin2pi-Tuple{Any}" href="#DFTK.sin2pi-Tuple{Any}"><code>DFTK.sin2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute sin(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/cis2pi.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T" href="#DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T"><code>DFTK.solve_ΩplusK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_ΩplusK(basis::PlaneWaveBasis{T}, ψ, res, occupation;
             tol=1e-10, verbose=false) where {T}</code></pre><p>Return δψ where (Ω+K) δψ = rhs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/hessian.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Vararg{Any, 5}}} where T" href="#DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Vararg{Any, 5}}} where T"><code>DFTK.solve_ΩplusK_split</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solve the problem <code>(Ω+K) δψ = rhs</code> using a split algorithm, where <code>rhs</code> is typically <code>-δHextψ</code> (the negative matvec of an external perturbation with the SCF orbitals <code>ψ</code>) and <code>δψ</code> is the corresponding total variation in the orbitals <code>ψ</code>. Additionally returns:     - <code>δρ</code>:  Total variation in density)     - <code>δHψ</code>: Total variation in Hamiltonian applied to orbitals     - <code>δeigenvalues</code>: Total variation in eigenvalues     - <code>δVind</code>: Change in potential induced by <code>δρ</code> (the term needed on top of <code>δHextψ</code>       to get <code>δHψ</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/response/hessian.jl#L127-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T" href="#DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T"><code>DFTK.spglib_standardize_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns crystallographic conventional cell according to the International Table of Crystallography Vol A (ITA) in case <code>primitive=false</code>. If <code>primitive=true</code> the primitive lattice is returned in the convention of the reference work of Cracknell, Davies, Miller, and Love (CDML). Of note this has minor differences to the primitive setting choice made in the ITA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/spglib.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T" href="#DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T"><code>DFTK.sphericalbesselj_fast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sphericalbesselj_fast(l::Integer, x::Number)</code></pre><p>Returns the spherical Bessel function of the first kind j<em>l(x). Consistent with https://en.wikipedia.org/wiki/Bessel</em>function#Spherical<em>Bessel</em>functions and with <code>SpecialFunctions.sphericalbesselj</code>. Specialized for integer <code>0 &lt;= l &lt;= 5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/spherical_bessels.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.spin_components-Tuple{Symbol}" href="#DFTK.spin_components-Tuple{Symbol}"><code>DFTK.spin_components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Explicit spin components of the KS orbitals and the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Model.jl#L295-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.split_evenly-Tuple{Any, Any}" href="#DFTK.split_evenly-Tuple{Any, Any}"><code>DFTK.split_evenly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Split an iterable evenly into N chunks, which will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/split_evenly.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.standardize_atoms" href="#DFTK.standardize_atoms"><code>DFTK.standardize_atoms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply various standardisations to a lattice and a list of atoms. It uses spglib to detect symmetries (within <code>tol_symmetry</code>), then cleans up the lattice according to the symmetries (unless <code>correct_symmetry</code> is <code>false</code>) and returns the resulting standard lattice and atoms. If <code>primitive</code> is <code>true</code> (default) the primitive unit cell is returned, else the conventional unit cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L207-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_kgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete BZ grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L179-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_rgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete real-space grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L191-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_forces-Tuple{Model, Any}" href="#DFTK.symmetrize_forces-Tuple{Model, Any}"><code>DFTK.symmetrize_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize the forces in <em>reduced coordinates</em>, forces given as an array forces[iel][α,i]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L357-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_stresses-Tuple{Model, Any}" href="#DFTK.symmetrize_stresses-Tuple{Model, Any}"><code>DFTK.symmetrize_stresses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize the stress tensor, given as a Matrix in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L340-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_ρ-Tuple{Any, Any}" href="#DFTK.symmetrize_ρ-Tuple{Any, Any}"><code>DFTK.symmetrize_ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize a density by applying all the basis (by default) symmetries and forming the average.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L326-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetry_operations" href="#DFTK.symmetry_operations"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the symmetries given an atomic structure with optionally designated magnetic moments on each of the atoms. The symmetries are determined using spglib.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L97-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetry_operations-Tuple{Integer}" href="#DFTK.symmetry_operations-Tuple{Integer}"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the Symmetry operations given a <code>hall_number</code>.</p><p>This function allows to directly access to the space group operations in the <code>spglib</code> database. To specify the space group type with a specific choice, <code>hall_number</code> is used.</p><p>The definition of <code>hall_number</code> is found at <a href="https://spglib.readthedocs.io/en/latest/dataset.html#dataset-spg-get-dataset-spacegroup-type">Space group type</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}" href="#DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}"><code>DFTK.synchronize_device</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Synchronize data and finish all operations on the execution stream of the device. This needs to be called explicitly before a task finishes (e.g. in an <code>@spawn</code> block).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/architecture.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.to_cpu-Tuple{AbstractArray}" href="#DFTK.to_cpu-Tuple{AbstractArray}"><code>DFTK.to_cpu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array from a device (typically a GPU) to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/architecture.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.to_device-Tuple{DFTK.CPU, Any}" href="#DFTK.to_device-Tuple{DFTK.CPU, Any}"><code>DFTK.to_device</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array to a particular device (typically a GPU)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/architecture.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.todict-Tuple{Energies}" href="#DFTK.todict-Tuple{Energies}"><code>DFTK.todict</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert an <code>Energies</code> struct to a dictionary representation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Energies.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.total_local_potential-Tuple{Hamiltonian}" href="#DFTK.total_local_potential-Tuple{Hamiltonian}"><code>DFTK.total_local_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the total local potential of the given Hamiltonian, in real space in the spin components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/terms/Hamiltonian.jl#L207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.transfer_blochwave</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer Bloch wave between two basis sets. Limited feature set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L129-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}" href="#DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array <code>ψk_in</code> expanded on <code>kpt_in</code>, and produce <span>$ψ(r) e^{i ΔG·r}$</span> expanded on <code>kpt_out</code>. It is mostly useful for phonons. Beware: <code>ψk_out</code> can lose information if the shift <code>ΔG</code> is large or if the <code>G_vectors</code> differ between <code>k</code>-points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array <code>ψk</code> defined on basis<em>in <span>$k$</span>-point kpt</em>in to basis<em>out <span>$k$</span>-point kpt</em>out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_density-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.transfer_density-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.transfer_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer density (in real space) between two basis sets.</p><p>This function is fast by transferring only the Fourier coefficients from the small basis to the big basis.</p><p>Note that this implies that for even-sized small FFT grids doing the transfer small -&gt; big -&gt; small is not an identity (as the small basis has an unmatched Fourier component and the identity <span>$c_G = c_{-G}^\ast$</span> does not fully hold).</p><p>Note further that for the direction big -&gt; small employing this function does not give the same answer as using first <code>transfer_blochwave</code> and then <code>compute_density</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L155-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_mapping-Tuple{PlaneWaveBasis, PlaneWaveBasis}" href="#DFTK.transfer_mapping-Tuple{PlaneWaveBasis, PlaneWaveBasis}"><code>DFTK.transfer_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the index mapping between the global grids of two bases. Returns an iterator of 8 pairs <code>(block_in, block_out)</code>. Iterated over these pairs <code>x_out_fourier[block_out, :] = x_in_fourier[block_in, :]</code> does the transfer from the Fourier coefficients <code>x_in_fourier</code> (defined on <code>basis_in</code>) to <code>x_out_fourier</code> (defined on <code>basis_out</code>, equally provided as Fourier coefficients).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the index mapping between two bases. Returns two arrays <code>idcs_in</code> and <code>idcs_out</code> such that <code>ψkout[idcs_out] = ψkin[idcs_in]</code> does the transfer from <code>ψkin</code> (defined on <code>basis_in</code> and <code>kpt_in</code>) to <code>ψkout</code> (defined on <code>basis_out</code> and <code>kpt_out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/transfer.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.trapezoidal" href="#DFTK.trapezoidal"><code>DFTK.trapezoidal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trapezoidal(x, y)</code></pre><p>Integrate y(x) over x using trapezoidal method quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/quadrature.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.unfold_bz-Tuple{PlaneWaveBasis}" href="#DFTK.unfold_bz-Tuple{PlaneWaveBasis}"><code>DFTK.unfold_bz</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot; Convert a <code>basis</code> into one that doesn&#39;t use BZ symmetry. This is mainly useful for debug purposes (e.g. in cases we don&#39;t want to bother thinking about symmetries).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/symmetry.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.versioninfo" href="#DFTK.versioninfo"><code>DFTK.versioninfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DFTK.versioninfo([io::IO=stdout])</code></pre><p>Summary of version and configuration of DFTK and its key dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/versioninfo.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}" href="#DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}"><code>DFTK.weighted_ksum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sum an array over kpoints, taking weights into account</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/PlaneWaveBasis.jl#L489-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.write_w90_eig-Tuple{String, Any}" href="#DFTK.write_w90_eig-Tuple{String, Any}"><code>DFTK.write_w90_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write the eigenvalues in a format readable by Wannier90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L106-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}" href="#DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}"><code>DFTK.write_w90_win</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write a win file at the indicated prefix. Parameters to Wannier90 can be added as kwargs: e.g. <code>num_iter=500</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/external/wannier90.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T" href="#DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T"><code>DFTK.ylm_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the (l,m) real spherical harmonic Y<em>lm(r). Consistent with https://en.wikipedia.org/wiki/Table</em>of<em>spherical</em>harmonics#Real<em>spherical</em>harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/spherical_harmonics.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.zeros_like" href="#DFTK.zeros_like"><code>DFTK.zeros_like</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create an array of same &quot;array type&quot; as X filled with zeros, minimizing the number of allocations. This unifies CPU and GPU code, as the output will always be on the same device as the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/zeros_like.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.@timing-Tuple" href="#DFTK.@timing-Tuple"><code>DFTK.@timing</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Shortened version of the <code>@timeit</code> macro from <code>TimerOutputs</code>, which writes to the DFTK timer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/common/timer.jl#L10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.A-Tuple{Any, Any}" href="#DFTK.Smearing.A-Tuple{Any, Any}"><code>DFTK.Smearing.A</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>A</code> term in the Hermite delta expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L113-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.H-Tuple{Any, Any}" href="#DFTK.Smearing.H-Tuple{Any, Any}"><code>DFTK.Smearing.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard Hermite function using physicist&#39;s convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Entropy. Note that this is a function of the energy <code>x</code>, not of <code>occupation(x)</code>. This function satisfies s&#39; = x f&#39; (see https://www.vasp.at/vasp-workshop/k-points.pdf p. 12 and https://arxiv.org/pdf/1805.07144.pdf p. 18.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation" href="#DFTK.Smearing.occupation"><code>DFTK.Smearing.occupation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">occupation(S::SmearingFunction, x)</code></pre><p>Occupation at <code>x</code>, where in practice <code>x = (ε - εF) / temperature</code>. If temperature is zero, <code>(ε-εF)/temperature  = ±∞</code>. The occupation function is required to give 1 and 0 respectively in these cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.occupation_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Derivative of the occupation function, approximation to minus the delta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Vararg{Any, 4}}" href="#DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Vararg{Any, 4}}"><code>DFTK.Smearing.occupation_divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(f(x) - f(y))/(x - y), computed stably in the case where x and y are close</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/5b6ce69788f28ec836a191ab70bfac8180c13dce/src/Smearing.jl#L31-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer/gpu_computations/">« GPU computations</a><a class="docs-footer-nextpage" href="../publications/">Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 22 November 2023 17:12">Wednesday 22 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
